const std = @import("std");
const Allocator = std.mem.Allocator;
const config_module = @import("../config.zig");
const ZenvConfig = config_module.ZenvConfig;
const EnvironmentConfig = config_module.EnvironmentConfig;
const EnvironmentRegistry = config_module.EnvironmentRegistry;
const errors = @import("../errors.zig");
const fs = @import("std").fs;
const process = @import("std").process;

const parse_deps = @import("parse_deps.zig");
const environment = @import("environment.zig");

// Generates the standard header for shell scripts (internal)
fn generateShellScriptHeader(writer: anytype, env_name: []const u8, script_purpose: []const u8) !void {
    if (std.mem.eql(u8, script_purpose, "Setup")) {
        // For setup scripts, exit on error
        try writer.print(
            \\#!/bin/sh
            \\set -e # Exit on error for setup scripts
            \\
            \\# {s} script for '{s}' environment generated by zenv
            \\
        , .{ script_purpose, env_name });
    } else {
        // For activation scripts, don't exit on error
        try writer.print(
            \\#!/bin/sh
            \\# {s} script for '{s}' environment generated by zenv
            \\
        , .{ script_purpose, env_name });
    }
}

// Appends module purge, load, and check commands to a script buffer (internal)
fn appendModuleCommandsToScript(
    writer: anytype, // Use a writer directly
    allocator: Allocator, // Needed for temporary module list string
    env_config: *const EnvironmentConfig,
    include_package_check: bool, // Flag to include python package detection
) !void {
    // Use multi-line string for the initial block
    try writer.print(
        \\# Check if module command exists
        \\if command -v module >/dev/null 2>&1; then
        \\  echo '==> Purging all modules'
        \\  module --force purge
        \\
    , .{});

    if (env_config.modules.items.len > 0) {
        // Build the module list string separately for clarity
        var module_list_str = std.ArrayList(u8).init(allocator);
        defer module_list_str.deinit();
        for (env_config.modules.items, 0..) |module_name, idx| {
            if (idx > 0) try module_list_str.appendSlice(", ");
            try module_list_str.appendSlice(module_name);
        }

        try writer.print("  echo '==> Loading required modules'\n", .{});
        try writer.print("  echo 'Loading modules: {s}'\n", .{module_list_str.items});

        // Use set +e to prevent script from exiting on module load error
        try writer.print("  # Don't exit immediately on module load errors so we can intercept and handle them\n", .{});
        try writer.print("  set +e\n", .{});

        // Load each module with error checking
        for (env_config.modules.items) |module_name| {
            try writer.print(
                \\  module load {s}
                \\  if [ $? -ne 0 ]; then
                \\    echo "Error: Failed to load module '{s}'"
                \\    exit 1
                \\  fi
                \\
            , .{ module_name, module_name });
        }

        // Restore error exit mode
        try writer.print("  set -e\n", .{});
    } else {
        try writer.print("  echo '==> No modules specified to load'\n", .{});
    }

    // Optionally add code to detect packages provided by modules (for setup script)
    if (include_package_check) {
        try writer.print(
            \\  echo '==> Checking Python packages provided by modules'
            \\  MODULE_PACKAGES_FILE=$(mktemp)
            \\  # Try python3 first, then python if python3 fails
            \\  (python3 -m pip list --format=freeze > "$MODULE_PACKAGES_FILE" 2>/dev/null || python -m pip list --format=freeze > "$MODULE_PACKAGES_FILE" 2>/dev/null) || true
            \\  if [ -s "$MODULE_PACKAGES_FILE" ]; then
            \\    echo '==> Found packages from modules:'
            \\    echo -n '    '
            \\    # Extract just package names, sort, join with comma-space
            \\    cat "$MODULE_PACKAGES_FILE" | sed -E 's/==.*//;s/ .*//' | sort | tr '\n' ',' | sed 's/,/, /g' | sed 's/, $//'
            \\    echo ''
            \\  else
            \\    echo '==> No Python packages detected from modules'
            \\    # Ensure the file exists even if empty for later steps
            \\    touch "$MODULE_PACKAGES_FILE"
            \\  fi
            \\
        , .{});
    }

    try writer.print("else\n", .{});
    try writer.print("  echo '==> Module command not found, skipping module operations'\n", .{});

    if (include_package_check) {
        try writer.print("  MODULE_PACKAGES_FILE=$(mktemp) # Create empty temp file\n", .{});
    }
    try writer.print("fi\n\n", .{});
}

// Create activation script for the environment
pub fn createActivationScript(allocator: Allocator, env_config: *const EnvironmentConfig, env_name: []const u8, base_dir: []const u8) !void {
    // Forward to the new template-based implementation
    return @import("activation_template.zig").createScriptFromTemplate(allocator, env_config, env_name, base_dir);
}

// Prints the module load commands needed for manual activation to a writer
pub fn printManualActivationModuleCommands(
    allocator: Allocator,
    writer: anytype, // Should conform to std.io.Writer
    env_config: *const EnvironmentConfig,
) !void {
    // Suggest checking for module command before using it
    try writer.print("if command -v module >/dev/null 2>&1; then\n", .{});
    // Suggest purging first for clean state
    try writer.print("  module --force purge\n", .{});

    // Print module load commands with a clear list first
    if (env_config.modules.items.len > 0) {
        var modules_list = std.ArrayList(u8).init(allocator);
        defer modules_list.deinit();

        for (env_config.modules.items, 0..) |module_name, i| {
            if (i > 0) {
                try modules_list.appendSlice(", ");
            }
            try modules_list.appendSlice(module_name);
        }

        try writer.print("  echo 'Loading modules: {s}'\n", .{modules_list.items});

        // Print individual load commands
        for (env_config.modules.items) |module_name| {
            try writer.print("  module load {s}\n", .{module_name});
        }
    } else {
        try writer.print("  echo 'No modules to load'\n", .{});
    }

    try writer.print("else\n", .{});
    try writer.print("  echo 'Module command not available, skipping module operations'\n", .{});
    try writer.print("fi\n", .{});
}

// Helper function to escape shell values (single quotes)
// Uses a fixed buffer to avoid memory allocations
pub fn escapeShellValue(value: []const u8, writer: anytype) !void {
    for (value) |char| {
        if (char == '\'') {
            try writer.writeAll("'\\''");
        } else {
            try writer.writeByte(char);
        }
    }
}


// Executes a given shell script, inheriting stdio and handling errors
pub fn executeShellScript(allocator: Allocator, script_abs_path: []const u8, script_rel_path: []const u8) !void {
    std.log.info("Running script: {s}", .{script_abs_path});
    const argv = [_][]const u8{ "/bin/sh", script_abs_path };
    var child = process.Child.init(&argv, allocator);

    // Inherit stdio for real-time output
    child.stdout_behavior = .Inherit;
    child.stderr_behavior = .Inherit;
    child.stdin_behavior = .Inherit; // Allow user input if script needs it

    const term = try child.spawnAndWait();

    if (term != .Exited or term.Exited != 0) {
        // Just show a concise error message - since stdout/stderr is already inherited,
        // the actual error output from the module command will have been displayed already
        std.log.err("Script execution failed with exit code: {d}", .{term.Exited});

        // Only log debug info when enabled via environment variable
        const enable_debug_logs = blk: {
            const env_var = std.process.getEnvVarOwned(allocator, "ZENV_DEBUG") catch |err| {
                if (err == error.EnvironmentVariableNotFound) break :blk false;
                std.log.warn("Failed to check ZENV_DEBUG environment variable: {s}", .{@errorName(err)});
                break :blk false;
            };
            defer allocator.free(env_var);
            break :blk std.mem.eql(u8, env_var, "1") or
                std.mem.eql(u8, env_var, "true") or
                std.mem.eql(u8, env_var, "yes");
        };

        if (enable_debug_logs) {
            const script_content_debug = fs.cwd().readFileAlloc(allocator, script_rel_path, 1024 * 1024) catch |read_err| {
                std.log.err("Failed to read script content for debug log: {s}", .{@errorName(read_err)});
                return error.ProcessError;
            };
            defer allocator.free(script_content_debug);

            // Log to a debug file instead of stderr
            const debug_log_path = try std.fmt.allocPrint(allocator, "{s}.debug.log", .{script_rel_path});
            defer allocator.free(debug_log_path);

            var debug_file = fs.cwd().createFile(debug_log_path, .{}) catch |err| {
                std.log.err("Could not create debug log file: {s}", .{@errorName(err)});
                return error.ProcessError;
            };
            defer debug_file.close();

            _ = debug_file.writeAll(script_content_debug) catch {};
            std.log.debug("Script content written to debug log: {s}", .{debug_log_path});
        }

        // Check if this is a module load failure by reading the script content
        // This is a heuristic but should work for our use case
        const script_content = fs.cwd().readFileAlloc(allocator, script_rel_path, 1024 * 1024) catch |read_err| {
            std.log.err("Failed to read script content: {s}", .{@errorName(read_err)});
            return error.ProcessError;
        };
        defer allocator.free(script_content);

        // Check if this script contains module load commands and the specific error text
        if (std.mem.indexOf(u8, script_content, "module load") != null and
            std.mem.indexOf(u8, script_content, "Error: Failed to load module") != null) {
            return error.ModuleLoadError;
        }

        return error.ProcessError;
    }

    std.log.info("Script completed successfully: {s}", .{script_abs_path});
}

// Sets up the full environment: creates files, generates and runs setup script.
pub fn setupEnvironment(allocator: Allocator, env_config: *const EnvironmentConfig, env_name: []const u8, base_dir: []const u8, deps: []const []const u8, force_deps: bool) !void {
    std.log.info("Setting up environment '{s}' in base directory '{s}'...", .{env_name, base_dir});

    // Get absolute path of current working directory
    var abs_path_buf: [std.fs.max_path_bytes]u8 = undefined;
    const cwd_path = try std.fs.cwd().realpath(".", &abs_path_buf);

    // Validate dependencies first
    var valid_deps_list = try parse_deps.validateDependencies(allocator, deps, env_name);
    defer {
        // Important: Defer freeing the list *after* freeing potentially owned items
        // validateDependencies returns an ArrayList whose items point EITHER to the original `deps` slices
        // OR to slices owned by the caller of setupEnvironment (e.g., duplicated from reading files).
        // It does NOT allocate new strings for the deps itself. The caller owns the deps strings.
        // Therefore, we only need to deinit the ArrayList itself.
        valid_deps_list.deinit();
    }

    // Create requirements file path using base_dir
    const req_rel_path = try std.fs.path.join(allocator, &[_][]const u8{base_dir, env_name, "requirements.txt"});
    defer allocator.free(req_rel_path);
    const req_abs_path = try std.fs.path.join(allocator, &[_][]const u8{ cwd_path, req_rel_path });
    defer allocator.free(req_abs_path);

    // Write the validated dependencies to the requirements file
    std.log.info("Writing {d} validated dependencies to {s}", .{ valid_deps_list.items.len, req_rel_path });
    {
        var req_file = try fs.cwd().createFile(req_rel_path, .{});
        defer req_file.close();
        var bw = std.io.bufferedWriter(req_file.writer());
        const writer = bw.writer();

        if (valid_deps_list.items.len == 0) {
            std.log.warn("No valid dependencies found! Writing only a comment to requirements file.", .{});
            try writer.writeAll("# No valid dependencies found\n");
        } else {
            for (valid_deps_list.items) |dep| {
                try writer.print("{s}\n", .{dep});
                std.log.debug("Wrote dependency to file: {s}", .{dep});
            }
        }
        try bw.flush();
    }
    std.log.info("Created requirements file: {s}", .{req_abs_path});

    // Generate setup script path using base_dir
    const script_rel_path = try std.fs.path.join(allocator, &[_][]const u8{base_dir, env_name, "setup_env.sh"});
    defer allocator.free(script_rel_path);
    const script_abs_path = try std.fs.path.join(allocator, &[_][]const u8{ cwd_path, script_rel_path });
    defer allocator.free(script_abs_path);

    // Write setup script to file
    std.log.info("Writing setup script to {s}", .{script_rel_path});
    {
        var script_file = try fs.cwd().createFile(script_rel_path, .{});
        defer script_file.close();
        var bw = std.io.bufferedWriter(script_file.writer());
        const writer = bw.writer();

        // 1. Script header
        try generateShellScriptHeader(writer, env_name, "Setup");

        // 2. Module commands (purge, load, check provided packages)
        try appendModuleCommandsToScript(writer, allocator, env_config, true);

        // 3. Create virtual environment using base_dir
        const venv_dir = try std.fs.path.join(allocator, &[_][]const u8{ cwd_path, base_dir, env_name });
        defer allocator.free(venv_dir);
        try writer.print(
            \\echo '==> Step 3: Creating Python virtual environment'
            \\# Try configured python executable first, then python3, then python
            \\VENV_CREATED=false
            \\if command -v {s} >/dev/null 2>&1; then
            \\  echo "Using configured Python: {s}"
            \\  {s} -m venv {s} && VENV_CREATED=true
            \\fi
            \\if [ "$VENV_CREATED" = false ] && command -v python3 >/dev/null 2>&1; then
            \\  echo "Falling back to 'python3' executable"
            \\  python3 -m venv {s} && VENV_CREATED=true
            \\fi
            \\if [ "$VENV_CREATED" = false ] && command -v python >/dev/null 2>&1; then
            \\  echo "Falling back to 'python' executable"
            \\  python -m venv {s} && VENV_CREATED=true
            \\fi
            \\if [ "$VENV_CREATED" = false ]; then
            \\  echo "ERROR: Failed to find a suitable Python executable ('{s}', 'python3', or 'python') to create venv."
            \\  exit 1
            \\fi
            \\
        , .{
            env_config.python_executable, env_config.python_executable, env_config.python_executable, venv_dir,
            venv_dir,                     venv_dir,                     env_config.python_executable,
        });

        // 4. Activate and install dependencies with module package filtering logic
        try writer.print(
            \\echo '==> Step 4: Activating environment and installing dependencies'
            \\source {s}/bin/activate
            \\# Ensure pip is available and upgrade it
            \\if ! python -m pip --version >/dev/null 2>&1; then
            \\  echo "ERROR: 'pip' module not found after activating venv. Ensure Python installation includes pip."
            \\  exit 1
            \\fi
            \\python -m pip install --upgrade pip
            \\
            \\# Filter requirements to potentially exclude packages provided by modules
        , .{venv_dir});

        if (force_deps) {
            try writer.print(
                \\# --force-deps specified: Installing all dependencies regardless of modules
                \\echo '==> Using --force-deps: Installing all specified dependencies'
            , .{});
            if (valid_deps_list.items.len > 0) {
                try writer.print("python -m pip install -r {s}\n\n", .{req_abs_path});
            } else {
                try writer.print("echo '==> No dependencies in requirements file to install.'\n\n", .{});
            }
            // Clean up module package file if it exists
            try writer.print("rm -f \"$MODULE_PACKAGES_FILE\" 2>/dev/null || true\n", .{});
        } else {
            // Non-force-deps: Filter based on modules
            try writer.print(
                \\# Comparing requirements file with packages potentially provided by modules
                \\if [ -n "$MODULE_PACKAGES_FILE" ] && [ -s "$MODULE_PACKAGES_FILE" ]; then
                \\  echo '==> Filtering requirements against module-provided packages (checking $MODULE_PACKAGES_FILE)'
                \\  FILTERED_REQUIREMENTS=$(mktemp)
                \\  EXCLUDED_COUNT=0
                \\  INSTALLED_COUNT=0
                \\  # EXCLUDED_LIST="" # Uncomment if summary needed
                \\  while IFS= read -r line || [ -n "$line" ]; do
                \\    # Trim whitespace and skip comments/empty lines
                \\    trimmed_line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                \\    if [ -z "$trimmed_line" ] || [[ "$trimmed_line" == "#"* ]]; then
                \\      continue
                \\    fi
                \\    # Extract base package name (lowercase, remove extras and version specifiers)
                \\    package_name=$(echo "$trimmed_line" | sed 's/[^a-zA-Z0-9_.-].*//' | tr '[:upper:]' '[:lower:]')
                \\    # Check if package name exists in module packages file (case-insensitive)
                \\    # Match variations like 'package_name==' or 'package-name ' (editable installs)
                \\    if grep -i -q "^${{package_name}}==" "$MODULE_PACKAGES_FILE" || grep -i -q "^${{package_name}} " "$MODULE_PACKAGES_FILE"; then
                \\      echo "==> Excluding '$trimmed_line' (provided by loaded modules)"
                \\      EXCLUDED_COUNT=$((EXCLUDED_COUNT + 1))
                \\      # EXCLUDED_LIST="${{EXCLUDED_LIST}}${{package_name}}\n" # Uncomment if summary needed
                \\    else
                \\      # Package not found in modules, add to filtered requirements
                \\      echo "$line" >> "$FILTERED_REQUIREMENTS"
                \\      INSTALLED_COUNT=$((INSTALLED_COUNT + 1))
                \\    fi
                \\  done < "{s}"
                \\
                \\  echo "==> Installing $INSTALLED_COUNT package(s) from filtered requirements file ($EXCLUDED_COUNT excluded)."
                \\  if [ -s "$FILTERED_REQUIREMENTS" ]; then
                \\    python -m pip install -r "$FILTERED_REQUIREMENTS"
                \\  else
                \\    echo '==> No additional packages need to be installed.'
                \\  fi
                \\  # Report excluded packages (Optional)
                \\  # if [ $EXCLUDED_COUNT -gt 0 ]; then
                \\  #   echo -e '\n==> Summary of packages excluded (provided by modules):'
                \\  #   echo -e "$EXCLUDED_LIST" | sort | uniq
                \\  # fi
                \\  # Cleanup temp files
                \\  rm -f "$FILTERED_REQUIREMENTS" "$MODULE_PACKAGES_FILE"
                \\else
                \\  # Module command failed or no module packages detected, install all requirements
                \\  echo '==> No module packages detected or module command unavailable. Installing all dependencies from requirements file.'
            , .{req_abs_path}); // req_abs_path for the 'done <' part
            if (valid_deps_list.items.len > 0) {
                try writer.print("  python -m pip install -r {s}\n", .{req_abs_path});
            } else {
                try writer.print("  echo '==> No dependencies in requirements file to install.'\n", .{});
            }
            // Clean up module package file if it exists
            try writer.print(
                \\  rm -f "$MODULE_PACKAGES_FILE" 2>/dev/null || true
                \\fi
                \\
            , .{});
        }

        // 5. Run custom commands if any
        if (env_config.setup_commands != null and env_config.setup_commands.?.items.len > 0) {
            try writer.print(
                \\echo '==> Step 5: Running custom setup commands'
                \\# Activate again just in case custom commands need the venv
                \\source {s}/bin/activate
            , .{venv_dir});
            for (env_config.setup_commands.?.items) |cmd| {
                try writer.print("{s}\n", .{cmd});
            }
            try writer.print("\n", .{});
        }

        // 6. Completion message
        const activate_script_path = try std.fs.path.join(allocator, &[_][]const u8{ cwd_path, base_dir, env_name, "activate.sh" });
        defer allocator.free(activate_script_path);
        try writer.print(
            \\echo '==> Setup completed successfully!'
            \\echo 'To activate this environment, run: source {s}'
            \\
        , .{activate_script_path});

        // Flush buffer and set executable permissions
        try bw.flush();
        try script_file.chmod(0o755); // Make executable
    }
    std.log.info("Created setup script: {s}", .{script_abs_path});

    // Execute setup script
    executeShellScript(allocator, script_abs_path, script_rel_path) catch |err| {
        if (err == error.ModuleLoadError) {
            // Let this error propagate up as is
            return err;
        }
        // For other errors, propagate as ProcessError
        std.log.err("Setup script execution failed.", .{}); // Add context
        return error.ProcessError;
    };

    std.log.info("Environment '{s}' setup completed successfully.", .{env_name});
}