#!/bin/bash
set -e
# Setup script for '@@ENV_NAME@@' environment generated by zenv

ohai() {
  printf '\033[0;34minfo:\033[0;39m %s\033[0m\n' "$@"
}
success() {
  printf '\033[1;32minfo:\033[1;39m %s\033[0m\n' "$@"
}
info() {
  printf '\033[1;33minfo:\033[0m %s\n' "$@"
}
warn() {
  printf '\033[1;31mWarning:\033[0m: %s\n' "$@" >&2
}
abort() {
  printf '\033[1;31mError:\033[0m: %s\n' "$@" >&2
  exit 1
}

LOG_FILE="@@VENV_DIR@@/zenv_setup.log"
echo "=== Setup script started at $(date) ===" >> "$LOG_FILE"
echo "Command: @@COMMAND_STRING@@" >> "$LOG_FILE"

exec > >(tee -a "$LOG_FILE") 2>&1

ohai "Command: @@COMMAND_STRING@@"

handle_module_error() {
  warn "Failed to load module '$1'"
  warn "This may be due to a typo, encoding issue, or the module not being available."
  warn "Continuing with setup, but functionality may be limited."

  if command -v module >/dev/null 2>&1; then
    local module_pattern=$(echo "$1" | tr -c '[:alnum:]' '.')
    if [ -n "$module_pattern" ]; then
      info "Modules that might match (grep pattern '${module_pattern}'):"
      module avail 2>/dev/null | grep -i "$module_pattern" | head -n 5 | sed 's/^/    Suggestion: /' || true
    fi
  fi
}

safe_module_load() {
  local module_name="$1"
  if echo "$module_name" | LC_ALL=C grep -q '[^[:print:]]'; then
    warn "Module name contains non-printable characters. Displaying hex representation:"
    echo -n "$module_name" | hexdump -C
    warn "Skipping problematic module."
    return 1
  fi

  info "Loading module (exact name): '$module_name'"

  module load "$module_name" 2>/tmp/zenv_module_err || {
    local err_output=$(cat /tmp/zenv_module_err)
    warn "Failed to load module '$module_name': $err_output"
    return 1
  }

  info "Successfully loaded module: $module_name"
  return 0
}

@@REBUILD_ENV_VALUE@@ # Sets REBUILD_ENV shell variable
if [ "$REBUILD_ENV" = "true" ]; then
  ohai "Upgrade flag (--rebuild) detected."
  info "Will attempt to upgrade existing Python in venv, or create new if missing/corrupted."
else
  ohai "Normal setup mode (create if missing/corrupted, use existing if valid)."
fi

@@USE_DEFAULT_PYTHON_VALUE@@
if [ "$USE_DEFAULT_PYTHON" = "true" ]; then
  ohai "Python flag (--python) detected"
  info "Will use only the default Python from ZENV_DIR/default-python"
fi

@@DEV_MODE_VALUE@@
if [ "$DEV_MODE" = "true" ]; then
  ohai "Development mode flag (--dev) detected"
  info "Will install current directory as an editable package"
fi

@@MODULES_VERIFIED_VALUE@@

@@USE_UV_VALUE@@
if [ "$USE_UV" = "true" ]; then
  ohai "--uv flag detected. Attempting to use 'uv' for package operations."
  if ! command -v uv >/dev/null 2>&1; then
    abort "'uv' command not found, but --uv flag was specified. Please install uv or run without --uv."
  fi
  info "Using uv version: $(uv --version)"
fi

@@NO_CACHE_VALUE@@
if [ "$NO_CACHE" = "true" ]; then
  ohai "--no-cache flag detected. Will disable package cache during installation."
fi

if command -v module >/dev/null 2>&1; then
  ohai "Purging all modules"
  module --force purge

  set +e  # Don't exit on module load errors

  ohai "Beginning module loading process"
  if [ "$MODULES_VERIFIED" = "true" ]; then
    info "Modules were pre-verified, proceeding with loading"
    @@MODULE_LOADING_BLOCK@@
  else
    @@MODULE_LOADING_BLOCK@@
  fi

  set -e

  MODULE_PYTHON=""
  if command -v python3 >/dev/null 2>&1; then
    MODULE_PYTHON=$(which python3)
    ohai "Found Python in PATH after loading modules: $MODULE_PYTHON"
    if $MODULE_PYTHON --version >/dev/null 2>&1; then
      info "Python version: $($MODULE_PYTHON --version 2>&1)"
    else
      warn "Python executable exists but failed to get version. It may be misconfigured."
      MODULE_PYTHON=""
    fi
  elif command -v python >/dev/null 2>&1; then
    MODULE_PYTHON=$(which python)
    ohai "Found Python in PATH after loading modules: $MODULE_PYTHON"
    if $MODULE_PYTHON --version >/dev/null 2>&1; then
      info "Python version: $($MODULE_PYTHON --version 2>&1)"
    else
      warn "Python executable exists but failed to get version. It may be misconfigured."
      MODULE_PYTHON=""
    fi
  else
    warn "No Python found in PATH after loading modules."
    if [ -n "@@FALLBACK_PYTHON@@" ] && [ "@@FALLBACK_PYTHON@@" != "python3" ]; then
      info "Will try fallback Python: @@FALLBACK_PYTHON@@"
    else
      info "Will try system Python executables"
    fi
  fi

  if command -v module >/dev/null 2>&1; then
    info "Currently loaded modules:"
    module avail 2>/dev/null | grep -i "^  " | head -n 20 | sed 's/^/    Available: /' || true
    info "Currently loaded modules:"
    module list 2>&1 | sed 's/^/    Loaded: /' || echo "    Failed to list modules"
  fi

  ohai "Checking Python packages provided by modules"
  MODULE_PACKAGES_FILE=$(mktemp)
  if [ -n "$MODULE_PYTHON" ]; then
    $MODULE_PYTHON -m pip list --format=freeze | awk -F'==' '{print $1}' | sort > "$MODULE_PACKAGES_FILE" 2>/dev/null || true
  else
    (python3 -m pip list --format=freeze | awk -F'==' '{print $1}' | sort > "$MODULE_PACKAGES_FILE" 2>/dev/null || python -m pip list --format=freeze | awk -F'==' '{print $1}' | sort > "$MODULE_PACKAGES_FILE" 2>/dev/null) || true
  fi

  if [ -s "$MODULE_PACKAGES_FILE" ]; then
    ohai "Found packages from modules:"
    echo -n '    '
    cat "$MODULE_PACKAGES_FILE" | sed -E 's/==.*//;s/ .*//' | sort | tr '\n' ',' | sed 's/,/, /g' | sed 's/, $//'
    echo ''
  else
    ohai "No Python packages detected from modules"
    touch "$MODULE_PACKAGES_FILE"
  fi
else
  ohai "Module command not found, skipping module operations"
  MODULE_PACKAGES_FILE=$(mktemp) # Create empty temp file
  MODULE_PYTHON="" # Ensure this is empty when no modules are loaded
fi

ohai "Step 3: Preparing Python virtual environment"

SELECTED_PYTHON_EXE=""
PYTHON_DESCRIPTION=""

if [ "$USE_DEFAULT_PYTHON" = "true" ]; then
  if [ -n "@@FALLBACK_PYTHON@@" ] && [ "@@FALLBACK_PYTHON@@" != "python3" ] && command -v "@@FALLBACK_PYTHON@@" >/dev/null 2>&1; then
    SELECTED_PYTHON_EXE="@@FALLBACK_PYTHON@@"
    PYTHON_DESCRIPTION="default configured Python (from --python flag)"
  else
    abort "Default Python (@@FALLBACK_PYTHON@@) not found or invalid, but --python flag was specified."
  fi
elif [ -n "$MODULE_PYTHON" ] && command -v "$MODULE_PYTHON" >/dev/null 2>&1; then
  SELECTED_PYTHON_EXE="$MODULE_PYTHON"
  PYTHON_DESCRIPTION="module-provided Python"
elif [ -n "@@FALLBACK_PYTHON@@" ] && [ "@@FALLBACK_PYTHON@@" != "python3" ] && command -v "@@FALLBACK_PYTHON@@" >/dev/null 2>&1; then
  SELECTED_PYTHON_EXE="@@FALLBACK_PYTHON@@"
  PYTHON_DESCRIPTION="fallback Python"
elif command -v "python3" >/dev/null 2>&1; then
  SELECTED_PYTHON_EXE="python3"
  PYTHON_DESCRIPTION="system python3"
elif command -v "python" >/dev/null 2>&1; then
  SELECTED_PYTHON_EXE="python"
  PYTHON_DESCRIPTION="system python"
else
  abort "Failed to find a suitable Python executable. Please ensure Python is installed and in PATH."
fi

ohai "Selected Python for venv: $PYTHON_DESCRIPTION ($SELECTED_PYTHON_EXE)"
info "Version: $($SELECTED_PYTHON_EXE --version 2>&1)"

if ! "$SELECTED_PYTHON_EXE" -c "import venv" 2>/dev/null; then
    abort "$PYTHON_DESCRIPTION ($SELECTED_PYTHON_EXE) does not support the venv module."
fi

VENV_DIR="@@VENV_DIR@@"
PYTHON_EXE_IN_VENV="$VENV_DIR/bin/python"
ACTIVATE_SCRIPT_IN_VENV="$VENV_DIR/bin/activate"

VENV_STATE="NEW" # Assume new by default
if [ -f "$PYTHON_EXE_IN_VENV" ] && [ -f "$ACTIVATE_SCRIPT_IN_VENV" ]; then
    VENV_STATE="VALID_EXISTING"
elif [ -f "$PYTHON_EXE_IN_VENV" ] || [ -d "$VENV_DIR/lib" ] || [ -d "$VENV_DIR/include" ]; then
    VENV_STATE="CORRUPTED_OR_INCOMPLETE"
elif [ ! -d "$VENV_DIR" ]; then 
    VENV_STATE="NON_EXISTENT"
fi


# --- Action Phase ---
PERFORM_VENV_CREATION=false
PERFORM_SELECTIVE_CLEAR=false

if [ "$REBUILD_ENV" = "true" ]; then
    if [ "$VENV_STATE" = "VALID_EXISTING" ]; then
        if [ -f "$VENV_DIR/pyvenv.cfg" ]; then
            EXISTING_PYTHON_PATH=$(grep "home =" "$VENV_DIR/pyvenv.cfg" | cut -d' ' -f3)
            SELECTED_PYTHON_PATH=$(dirname $(dirname $($SELECTED_PYTHON_EXE -c "import sys; print(sys.executable)")))

            if [ "$EXISTING_PYTHON_PATH" != "$SELECTED_PYTHON_PATH" ]; then
                ohai "--rebuild: Detected different Python path ($SELECTED_PYTHON_PATH vs $EXISTING_PYTHON_PATH)"
                ohai "--rebuild: Recreating virtual environment with new Python"
                PERFORM_SELECTIVE_CLEAR=true
                PERFORM_VENV_CREATION=true
            else
                ohai "--rebuild: Attempting to upgrade existing valid venv $VENV_DIR with $PYTHON_DESCRIPTION..."
                if "$SELECTED_PYTHON_EXE" -m venv --upgrade "$VENV_DIR"; then
                    success "Successfully upgraded venv."
                else
                    warn "Failed to upgrade venv. Will clear critical components and recreate."
                    PERFORM_SELECTIVE_CLEAR=true
                    PERFORM_VENV_CREATION=true
                fi
            fi
        else
            ohai "--rebuild: Cannot determine Python version of existing venv. Recreating..."
            PERFORM_SELECTIVE_CLEAR=true
            PERFORM_VENV_CREATION=true
        fi
    elif [ "$VENV_STATE" = "NEW" ]; then
        ohai "--rebuild: Venv directory $VENV_DIR is new or has no venv components. Creating new venv with $PYTHON_DESCRIPTION."
        PERFORM_VENV_CREATION=true
    elif [ "$VENV_STATE" = "CORRUPTED_OR_INCOMPLETE" ]; then
        ohai "--rebuild: Existing venv $VENV_DIR seems corrupted/incomplete. Clearing critical components and recreating with $PYTHON_DESCRIPTION."
        PERFORM_SELECTIVE_CLEAR=true
        PERFORM_VENV_CREATION=true
    elif [ "$VENV_STATE" = "NON_EXISTENT" ]; then # Handle if dir wasn't pre-created
        ohai "--rebuild: Venv directory $VENV_DIR does not exist. Creating new venv with $PYTHON_DESCRIPTION."
        PERFORM_VENV_CREATION=true
    fi
else # Not using --rebuild flag
    if [ "$VENV_STATE" = "VALID_EXISTING" ]; then
        ohai "Using existing valid virtual environment $VENV_DIR."
    elif [ "$VENV_STATE" = "NEW" ]; then
        ohai "Venv directory $VENV_DIR is new or has no venv components. Creating new venv with $PYTHON_DESCRIPTION."
        PERFORM_VENV_CREATION=true
    elif [ "$VENV_STATE" = "CORRUPTED_OR_INCOMPLETE" ]; then
        ohai "Existing venv $VENV_DIR seems corrupted/incomplete. Clearing critical components and recreating with $PYTHON_DESCRIPTION."
        PERFORM_SELECTIVE_CLEAR=true
        PERFORM_VENV_CREATION=true
    elif [ "$VENV_STATE" = "NON_EXISTENT" ]; then # Handle if dir wasn't pre-created
        ohai "Venv directory $VENV_DIR does not exist. Creating new venv with $PYTHON_DESCRIPTION."
        PERFORM_VENV_CREATION=true
    fi
fi

if [ "$PERFORM_SELECTIVE_CLEAR" = "true" ]; then
    info "Removing old venv components: $VENV_DIR/bin $VENV_DIR/lib $VENV_DIR/include $VENV_DIR/pyvenv.cfg $VENV_DIR/lib64"
    rm -rf "$VENV_DIR/bin" "$VENV_DIR/lib" "$VENV_DIR/include" "$VENV_DIR/pyvenv.cfg" "$VENV_DIR/lib64" 2>/dev/null || true
fi

if [ "$PERFORM_VENV_CREATION" = "true" ]; then
    if [ ! -d "$VENV_DIR" ]; then
        mkdir -p "$VENV_DIR" || abort "Failed to create directory $VENV_DIR for new venv."
    fi
    ohai "Creating/Recreating virtual environment in $VENV_DIR using $PYTHON_DESCRIPTION ($SELECTED_PYTHON_EXE)..."
    if "$SELECTED_PYTHON_EXE" -m venv "$VENV_DIR"; then
        success "Successfully created/recreated venv."
    else
        abort "Failed to create/recreate venv."
    fi
fi

ohai "Step 4: Activating environment and installing dependencies"
if [ ! -d "@@VENV_DIR@@" ] || [ ! -f "@@VENV_DIR@@/bin/activate" ]; then
  abort "Virtual environment not found or invalid at @@VENV_DIR@@
$(if [ -d "@@VENV_DIR@@" ] && [ ! -d "@@VENV_DIR@@/bin" ]; then
  echo "bin directory does not exist in @@VENV_DIR@@"
elif [ -d "@@VENV_DIR@@/bin" ]; then
  echo "bin directory contents:"
  ls -la "@@VENV_DIR@@/bin"
fi)
This could indicate that the virtual environment was not created properly."
fi

source "@@VENV_DIR@@/bin/activate"

if ! python -m pip --version >/dev/null 2>&1; then
  abort "'pip' module not found after activating venv. Ensure Python installation includes pip."
fi

ohai "Temporarily disabling .pyc file generation for package installation"
export PYTHONDONTWRITEBYTECODE=1

if [ "$USE_UV" = "true" ]; then
  ohai "Ensuring pip, setuptools, and wheel are up-to-date in the venv using uv"
  if [ "$NO_CACHE" = "true" ]; then
    uv pip install --no-cache --link-mode=copy --upgrade pip #setuptools wheel
  else
    uv pip install --link-mode=copy --upgrade pip #setuptools wheel
  fi
else
  ohai "Ensuring pip and it is up-to-date in the venv using pip"
  if [ "$NO_CACHE" = "true" ]; then
    python -m pip install --ignore-installed --no-build-isolation --no-cache-dir --upgrade pip #setuptools wheel
  else
    python -m pip install --ignore-installed --no-build-isolation --upgrade pip #setuptools wheel
  fi
fi

@@FORCE_DEPS_VALUE@@

REQUIREMENTS_PATH="@@REQUIREMENTS_PATH@@"
ohai "Using requirements file: $REQUIREMENTS_PATH (this file is generated by zenv based on your configuration)"

if [ ! -f "$REQUIREMENTS_PATH" ]; then
    warn "Critical: Requirements file $REQUIREMENTS_PATH was not found where zenv expected to create it."
    warn "An empty file will be touched to prevent pip failure"
    touch "$REQUIREMENTS_PATH"
fi
PIP_INSTALL_OPTIONS=""
if [ "$NO_CACHE" = "true" ]; then
  PIP_INSTALL_OPTIONS="$PIP_INSTALL_OPTIONS --no-cache-dir"
fi

if [ "$FORCE_DEPS" = "true" ]; then
  ohai "Using --force: Installing all specified dependencies from $REQUIREMENTS_PATH"
  if [ -s "$REQUIREMENTS_PATH" ]; then
    if [ "$USE_UV" = "true" ]; then
      if [ "$NO_CACHE" = "true" ]; then
        uv pip install --no-cache --link-mode=copy -r "$REQUIREMENTS_PATH"
      else
        uv pip install --link-mode=copy -r "$REQUIREMENTS_PATH"
      fi
    else
      python -m pip install $PIP_INSTALL_OPTIONS -r "$REQUIREMENTS_PATH"
    fi
  else
    info "No dependencies to install (requirements file $REQUIREMENTS_PATH is empty or not found)."
  fi
else
  if [ -s "$MODULE_PACKAGES_FILE" ]; then
    ohai "Filtering requirements against module-provided packages"
    FILTERED_REQUIREMENTS=$(mktemp)
    EXCLUDED_COUNT=0
    INSTALLED_COUNT=0

    if [ -s "$REQUIREMENTS_PATH" ]; then
      grep -v "^[[:space:]]*#" "$REQUIREMENTS_PATH" | grep -v "^[[:space:]]*$" | while read -r line; do
        package_name=$(echo "$line" | sed 's/[^a-zA-Z0-9_.-].*//' | tr '[:upper:]' '[:lower:]')

        if grep -i -q "^${package_name}$" "$MODULE_PACKAGES_FILE"; then
          info "Excluding '$line' (provided by loaded modules)"
          EXCLUDED_COUNT=$((EXCLUDED_COUNT + 1))
        else
          echo "$line" >> "$FILTERED_REQUIREMENTS"
          INSTALLED_COUNT=$((INSTALLED_COUNT + 1))
        fi
      done
    else
      info "Requirements file '$REQUIREMENTS_PATH' is empty or not found, so no packages to filter from it."
    fi

    ohai "Installing $INSTALLED_COUNT package(s) from filtered requirements ($EXCLUDED_COUNT excluded due to module conflicts)"
    if [ -s "$FILTERED_REQUIREMENTS" ]; then
      if [ "$USE_UV" = "true" ]; then
        if [ "$NO_CACHE" = "true" ]; then
          uv pip install --no-cache --link-mode=copy -r "$FILTERED_REQUIREMENTS"
        else
          uv pip install --link-mode=copy -r "$FILTERED_REQUIREMENTS"
        fi
      else
        python -m pip install $PIP_INSTALL_OPTIONS -r "$FILTERED_REQUIREMENTS"
      fi
    else
      info "No additional packages need to be installed (after filtering against module packages)."
    fi
    rm -f "$FILTERED_REQUIREMENTS"
  else
    ohai "No module packages to filter against, or module package list was empty."
    ohai "Installing all dependencies directly from $REQUIREMENTS_PATH"
    if [ -s "$REQUIREMENTS_PATH" ]; then
      if [ "$USE_UV" = "true" ]; then
        if [ "$NO_CACHE" = "true" ]; then
          uv pip install --no-cache --link-mode=copy -r "$REQUIREMENTS_PATH"
        else
          uv pip install --link-mode=copy -r "$REQUIREMENTS_PATH"
        fi
      else
        python -m pip install $PIP_INSTALL_OPTIONS -r "$REQUIREMENTS_PATH"
      fi
    else
      info "No dependencies to install (requirements file $REQUIREMENTS_PATH is empty or not found)."
    fi
  fi
fi


rm -f "$MODULE_PACKAGES_FILE" 2>/dev/null || true

if [ "$DEV_MODE" = "true" ]; then
  ohai "Step 4.5: Installing current directory as an editable package"

  if [ -f "setup.py" ] || [ -f "pyproject.toml" ]; then
    info "Found Python package configuration in current directory"
    if [ "$USE_UV" = "true" ]; then
      if [ "$NO_CACHE" = "true" ]; then
        uv pip install --no-cache --link-mode=copy --editable . --no-deps || {
          warn "Failed to install current directory as editable package using uv"
          warn "Check that your setup.py or pyproject.toml is valid"
        }
      else
        uv pip install --link-mode=copy --editable . --no-deps || {
          warn "Failed to install current directory as editable package using uv"
          warn "Check that your setup.py or pyproject.toml is valid"
        }
      fi
    else
      python -m pip install $PIP_INSTALL_OPTIONS --no-build-isolation --editable . --no-deps || {
        warn "Failed to install current directory as editable package using pip"
        warn "Check that your setup.py or pyproject.toml is valid"
      }
    fi
    info "Dependencies are handled separately according to module filtering rules"
    success "Installed current directory as editable package"
  else
    warn "No setup.py or pyproject.toml found in current directory"
    warn "Skipping editable install. Create one of these files if needed."
  fi
fi

if [ -n "$PYTHONDONTWRITEBYTECODE" ]; then
  ohai "Re-enabling .pyc file generation"
  unset PYTHONDONTWRITEBYTECODE
fi

@@CUSTOM_SETUP_COMMANDS_BLOCK@@
@@SETUP_HOOK_BLOCK@@

echo "=== Setup script completed at $(date) ===" >> "$LOG_FILE"
