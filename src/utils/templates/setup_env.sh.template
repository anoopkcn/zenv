#!/bin/bash
set -e # Exit on error for setup scripts

# Setup script for '@@ENV_NAME@@' environment generated by zenv

# Append to the existing log file created by zenv
LOG_FILE="@@VENV_DIR@@/zenv_setup.log"
echo "=== Setup script started at $(date) ===" >> "$LOG_FILE"

# Use bash process substitution to redirect all output to both console and log file
exec > >(tee -a "$LOG_FILE") 2>&1

# Print message in blue
ohai() {
  printf '\033[0;34minfo:\033[0;39m %s\033[0m\n' "$@"
}

# Print message in green
success() {
  printf '\033[1;32minfo:\033[1;39m %s\033[0m\n' "$@"
}

# Print message in yellow
info() {
  printf '\033[1;33minfo:\033[0m %s\n' "$@"
}

# Print warning message in red
warn() {
  printf '\033[1;31mWarning:\033[0m: %s\n' "$@" >&2
}

# Print error message and exit
abort() {
  printf '\033[1;31mError:\033[0m: %s\n' "$@" >&2
  exit 1
}

# Define a function to handle module errors
handle_module_error() {
  abort "Failed to load module '$1'"
}

# Handle upgrade_env flag
@@UPGRADE_ENV_VALUE@@ # Sets UPGRADE_ENV shell variable
if [ "$UPGRADE_ENV" = "true" ]; then
  ohai "Upgrade flag (--upgrade) detected."
  info "Will attempt to upgrade existing Python in venv, or create new if missing/corrupted."
else
  ohai "Normal setup mode (create if missing/corrupted, use existing if valid)."
fi

# Handle use_default_python flag
@@USE_DEFAULT_PYTHON_VALUE@@
if [ "$USE_DEFAULT_PYTHON" = "true" ]; then
  ohai "Python flag (--python) detected"
  info "Will use only the default Python from ZENV_DIR/default-python"
fi

# Handle development mode flag
@@DEV_MODE_VALUE@@
if [ "$DEV_MODE" = "true" ]; then
  ohai "Development mode flag (--dev) detected"
  info "Will install current directory as an editable package"
fi

# Handle modules_verified flag
@@MODULES_VERIFIED_VALUE@@

# Handle USE_UV flag
@@USE_UV_VALUE@@
if [ "$USE_UV" = "true" ]; then
  ohai "--uv flag detected. Attempting to use 'uv' for package operations."
  if ! command -v uv >/dev/null 2>&1; then
    abort "'uv' command not found, but --uv flag was specified. Please install uv or run without --uv."
  fi
  info "Using uv version: $(uv --version)"
fi

# Handle NO_CACHE flag
@@NO_CACHE_VALUE@@
if [ "$NO_CACHE" = "true" ]; then
  ohai "--no-cache flag detected. Will disable package cache during installation."
fi

# Check if module command exists
if command -v module >/dev/null 2>&1; then
  ohai "Purging all modules"
  module --force purge

  # Load modules based on verification status
  if [ "$MODULES_VERIFIED" = "true" ]; then
    # ohai "Modules were pre-verified, proceeding with loading"
    # We still need to load the modules to access the Python they provide
    # But if any fails, we'll continue since we verified they should work
    @@MODULE_LOADING_BLOCK@@
  else
    # Load all required modules with full error checking
    @@MODULE_LOADING_BLOCK@@
  fi

  # After loading modules, check which Python is now available in the PATH
  MODULE_PYTHON=""
  if command -v python3 >/dev/null 2>&1; then
    MODULE_PYTHON=$(which python3)
    ohai "Found Python in PATH after loading modules: $MODULE_PYTHON"
    info "Version: $($MODULE_PYTHON --version 2>&1)"
  elif command -v python >/dev/null 2>&1; then
    MODULE_PYTHON=$(which python)
    ohai "Found Python in PATH after loading modules: $MODULE_PYTHON"
    info "Version: $($MODULE_PYTHON --version 2>&1)"
  else
    warn "No Python found in PATH after loading modules."
    if [ -n "@@FALLBACK_PYTHON@@" ] && [ "@@FALLBACK_PYTHON@@" != "python3" ]; then
      info "Will try fallback Python: @@FALLBACK_PYTHON@@"
    else
      info "Will try system Python executables"
    fi
  fi

  ohai "Checking Python packages provided by modules"
  MODULE_PACKAGES_FILE=$(mktemp)
  # Use module Python if available, otherwise try system Python
  # Extract and preprocess package names for faster filtering
  if [ -n "$MODULE_PYTHON" ]; then
    $MODULE_PYTHON -m pip list --format=freeze | awk -F'==' '{print $1}' | sort > "$MODULE_PACKAGES_FILE" 2>/dev/null || true
  else
    (python3 -m pip list --format=freeze | awk -F'==' '{print $1}' | sort > "$MODULE_PACKAGES_FILE" 2>/dev/null || python -m pip list --format=freeze | awk -F'==' '{print $1}' | sort > "$MODULE_PACKAGES_FILE" 2>/dev/null) || true
  fi

  if [ -s "$MODULE_PACKAGES_FILE" ]; then
    ohai "Found packages from modules:"
    echo -n '    '
    # Extract just package names, sort, join with comma-space
    cat "$MODULE_PACKAGES_FILE" | sed -E 's/==.*//;s/ .*//' | sort | tr '\n' ',' | sed 's/,/, /g' | sed 's/, $//'
    echo ''
  else
    ohai "No Python packages detected from modules"
    # Ensure the file exists even if empty for later steps
    touch "$MODULE_PACKAGES_FILE"
  fi
else
  ohai "Module command not found, skipping module operations"
  MODULE_PACKAGES_FILE=$(mktemp) # Create empty temp file
  MODULE_PYTHON="" # Ensure this is empty when no modules are loaded
fi

ohai "Step 3: Preparing Python virtual environment"

# Determine selected Python executable for venv creation/upgrade
# This logic should consolidate MODULE_PYTHON, FALLBACK_PYTHON, system pythons
SELECTED_PYTHON_EXE=""
PYTHON_DESCRIPTION=""

# Priority:
# 1. --python flag (forces FALLBACK_PYTHON if it's from zenv default, errors if not found)
# 2. Module Python
# 3. Fallback Python (from zenv.json or zenv default)
# 4. System python3
# 5. System python

if [ "$USE_DEFAULT_PYTHON" = "true" ]; then
  if [ -n "@@FALLBACK_PYTHON@@" ] && [ "@@FALLBACK_PYTHON@@" != "python3" ] && command -v "@@FALLBACK_PYTHON@@" >/dev/null 2>&1; then
    SELECTED_PYTHON_EXE="@@FALLBACK_PYTHON@@"
    PYTHON_DESCRIPTION="default configured Python (from --python flag)"
  else
    abort "Default Python (@@FALLBACK_PYTHON@@) not found or invalid, but --python flag was specified."
  fi
elif [ -n "$MODULE_PYTHON" ] && command -v "$MODULE_PYTHON" >/dev/null 2>&1; then
  SELECTED_PYTHON_EXE="$MODULE_PYTHON"
  PYTHON_DESCRIPTION="module-provided Python"
elif [ -n "@@FALLBACK_PYTHON@@" ] && [ "@@FALLBACK_PYTHON@@" != "python3" ] && command -v "@@FALLBACK_PYTHON@@" >/dev/null 2>&1; then
  SELECTED_PYTHON_EXE="@@FALLBACK_PYTHON@@"
  PYTHON_DESCRIPTION="fallback Python"
elif command -v "python3" >/dev/null 2>&1; then
  SELECTED_PYTHON_EXE="python3"
  PYTHON_DESCRIPTION="system python3"
elif command -v "python" >/dev/null 2>&1; then
  SELECTED_PYTHON_EXE="python"
  PYTHON_DESCRIPTION="system python"
else
  abort "Failed to find a suitable Python executable. Please ensure Python is installed and in PATH."
fi

ohai "Selected Python for venv: $PYTHON_DESCRIPTION ($SELECTED_PYTHON_EXE)"
info "Version: $($SELECTED_PYTHON_EXE --version 2>&1)"

if ! "$SELECTED_PYTHON_EXE" -c "import venv" 2>/dev/null; then
    abort "$PYTHON_DESCRIPTION ($SELECTED_PYTHON_EXE) does not support the venv module."
fi

VENV_DIR="@@VENV_DIR@@"
PYTHON_EXE_IN_VENV="$VENV_DIR/bin/python"
ACTIVATE_SCRIPT_IN_VENV="$VENV_DIR/bin/activate"

# Determine current state of the VENV_DIR
VENV_STATE="NEW" # Assume new by default
if [ -f "$PYTHON_EXE_IN_VENV" ] && [ -f "$ACTIVATE_SCRIPT_IN_VENV" ]; then
    VENV_STATE="VALID_EXISTING"
elif [ -f "$PYTHON_EXE_IN_VENV" ] || [ -d "$VENV_DIR/lib" ] || [ -d "$VENV_DIR/include" ]; then
    # If python executable exists, or lib/include dirs exist, but not a full valid venv,
    # it's likely corrupted or incomplete.
    VENV_STATE="CORRUPTED_OR_INCOMPLETE"
# If VENV_DIR exists but none of the above venv components are found, it remains "NEW"
# (meaning the dir was likely pre-created by zenv but venv setup hasn't run/completed)
elif [ ! -d "$VENV_DIR" ]; then # This case should ideally not happen if zenv creates the dir first
    VENV_STATE="NON_EXISTENT" # Explicitly handle if zenv didn't create the dir
fi


# --- Action Phase ---
PERFORM_VENV_CREATION=false
PERFORM_SELECTIVE_CLEAR=false

if [ "$UPGRADE_ENV" = "true" ]; then
    if [ "$VENV_STATE" = "VALID_EXISTING" ]; then
        # Check what Python the existing venv is using
        if [ -f "$VENV_DIR/pyvenv.cfg" ]; then
            EXISTING_PYTHON_PATH=$(grep "home =" "$VENV_DIR/pyvenv.cfg" | cut -d' ' -f3)
            SELECTED_PYTHON_PATH=$(dirname $(dirname $($SELECTED_PYTHON_EXE -c "import sys; print(sys.executable)")))

            if [ "$EXISTING_PYTHON_PATH" != "$SELECTED_PYTHON_PATH" ]; then
                ohai "--upgrade: Detected different Python path ($SELECTED_PYTHON_PATH vs $EXISTING_PYTHON_PATH)"
                ohai "--upgrade: Recreating virtual environment with new Python"
                PERFORM_SELECTIVE_CLEAR=true
                PERFORM_VENV_CREATION=true
            else
                ohai "--upgrade: Attempting to upgrade existing valid venv $VENV_DIR with $PYTHON_DESCRIPTION..."
                if "$SELECTED_PYTHON_EXE" -m venv --upgrade "$VENV_DIR"; then
                    success "Successfully upgraded venv."
                else
                    warn "Failed to upgrade venv. Will clear critical components and recreate."
                    PERFORM_SELECTIVE_CLEAR=true
                    PERFORM_VENV_CREATION=true
                fi
            fi
        else
            ohai "--upgrade: Cannot determine Python version of existing venv. Recreating..."
            PERFORM_SELECTIVE_CLEAR=true
            PERFORM_VENV_CREATION=true
        fi
    elif [ "$VENV_STATE" = "NEW" ]; then
        ohai "--upgrade: Venv directory $VENV_DIR is new or has no venv components. Creating new venv with $PYTHON_DESCRIPTION."
        PERFORM_VENV_CREATION=true
    elif [ "$VENV_STATE" = "CORRUPTED_OR_INCOMPLETE" ]; then
        ohai "--upgrade: Existing venv $VENV_DIR seems corrupted/incomplete. Clearing critical components and recreating with $PYTHON_DESCRIPTION."
        PERFORM_SELECTIVE_CLEAR=true
        PERFORM_VENV_CREATION=true
    elif [ "$VENV_STATE" = "NON_EXISTENT" ]; then # Handle if dir wasn't pre-created
        ohai "--upgrade: Venv directory $VENV_DIR does not exist. Creating new venv with $PYTHON_DESCRIPTION."
        PERFORM_VENV_CREATION=true
    fi
else # Not using --upgrade flag
    if [ "$VENV_STATE" = "VALID_EXISTING" ]; then
        ohai "Using existing valid virtual environment $VENV_DIR."
        # No action needed on venv itself
    elif [ "$VENV_STATE" = "NEW" ]; then
        ohai "Venv directory $VENV_DIR is new or has no venv components. Creating new venv with $PYTHON_DESCRIPTION."
        PERFORM_VENV_CREATION=true
    elif [ "$VENV_STATE" = "CORRUPTED_OR_INCOMPLETE" ]; then
        ohai "Existing venv $VENV_DIR seems corrupted/incomplete. Clearing critical components and recreating with $PYTHON_DESCRIPTION."
        PERFORM_SELECTIVE_CLEAR=true
        PERFORM_VENV_CREATION=true
    elif [ "$VENV_STATE" = "NON_EXISTENT" ]; then # Handle if dir wasn't pre-created
        ohai "Venv directory $VENV_DIR does not exist. Creating new venv with $PYTHON_DESCRIPTION."
        PERFORM_VENV_CREATION=true
    fi
fi

if [ "$PERFORM_SELECTIVE_CLEAR" = "true" ]; then
    info "Removing old venv components: $VENV_DIR/bin $VENV_DIR/lib $VENV_DIR/include $VENV_DIR/pyvenv.cfg $VENV_DIR/lib64"
    rm -rf "$VENV_DIR/bin" "$VENV_DIR/lib" "$VENV_DIR/include" "$VENV_DIR/pyvenv.cfg" "$VENV_DIR/lib64" 2>/dev/null || true
fi

if [ "$PERFORM_VENV_CREATION" = "true" ]; then
    # Ensure the base directory for the venv exists before trying to create in it
    # This is important if VENV_STATE was NON_EXISTENT
    if [ ! -d "$VENV_DIR" ]; then
        mkdir -p "$VENV_DIR" || abort "Failed to create directory $VENV_DIR for new venv."
    fi
    ohai "Creating/Recreating virtual environment in $VENV_DIR using $PYTHON_DESCRIPTION ($SELECTED_PYTHON_EXE)..."
    if "$SELECTED_PYTHON_EXE" -m venv "$VENV_DIR"; then
        success "Successfully created/recreated venv."
    else
        abort "Failed to create/recreate venv."
    fi
fi

# --- End of Venv Setup ---

ohai "Step 4: Activating environment and installing dependencies"
# Verify the virtual environment exists and is valid
if [ ! -d "@@VENV_DIR@@" ] || [ ! -f "@@VENV_DIR@@/bin/activate" ]; then
  abort "Virtual environment not found or invalid at @@VENV_DIR@@
$(if [ -d "@@VENV_DIR@@" ] && [ ! -d "@@VENV_DIR@@/bin" ]; then
  echo "bin directory does not exist in @@VENV_DIR@@"
elif [ -d "@@VENV_DIR@@/bin" ]; then
  echo "bin directory contents:"
  ls -la "@@VENV_DIR@@/bin"
fi)
This could indicate that the virtual environment was not created properly."
fi

# Activate the environment
source "@@VENV_DIR@@/bin/activate"

# Ensure pip is available and upgrade it
if ! python -m pip --version >/dev/null 2>&1; then
  abort "'pip' module not found after activating venv. Ensure Python installation includes pip."
fi

# Prevent Python from writing .pyc files during setup to save inodes
ohai "Temporarily disabling .pyc file generation for package installation"
export PYTHONDONTWRITEBYTECODE=1

# Ensure build essentials are there, especially if venv was just created/upgraded
if [ "$USE_UV" = "true" ]; then
  ohai "Ensuring pip, setuptools, and wheel are up-to-date in the venv using uv"
  # Using uv pip install for these core tools.
  # uv doesn't have a direct equivalent for --no-build-isolation for *these specific* tools.
  # It's generally fine as uv handles build environments differently.
  if [ "$NO_CACHE" = "true" ]; then
    uv pip install --no-cache --link-mode=copy --upgrade pip #setuptools wheel
  else
    uv pip install --link-mode=copy --upgrade pip #setuptools wheel
  fi
else
  ohai "Ensuring pip and it is up-to-date in the venv using pip"
  if [ "$NO_CACHE" = "true" ]; then
    python -m pip install --ignore-installed --no-build-isolation --no-cache-dir --upgrade pip #setuptools wheel
  else
    python -m pip install --ignore-installed --no-build-isolation --upgrade pip #setuptools wheel
  fi
fi

# Handle dependencies installation based on force_deps flag
@@FORCE_DEPS_VALUE@@

# Resolve requirements file path
REQUIREMENTS_PATH="@@REQUIREMENTS_PATH@@"
ohai "Using requirements file: $REQUIREMENTS_PATH (this file is generated by zenv based on your configuration)"

if [ ! -f "$REQUIREMENTS_PATH" ]; then
    # This case indicates an issue upstream in zenv's file generation if it was expected to exist.
    warn "Critical: Requirements file $REQUIREMENTS_PATH was not found where zenv expected to create it."
    warn "An empty file will be touched to prevent pip failure, but package installation will likely be incomplete."
    touch "$REQUIREMENTS_PATH"
fi
# At this point, $REQUIREMENTS_PATH should point to the file zenv intended to create/use.
# Its content (or lack thereof) will be checked by subsequent -s tests.

# Install dependencies
PIP_INSTALL_OPTIONS="" # Base option - ensure we don't ignore already installed packages by default
if [ "$NO_CACHE" = "true" ]; then
  PIP_INSTALL_OPTIONS="$PIP_INSTALL_OPTIONS --no-cache-dir"
fi

if [ "$FORCE_DEPS" = "true" ]; then
  # Install all dependencies regardless of module packages
  ohai "Using --force: Installing all specified dependencies from $REQUIREMENTS_PATH"
  if [ -s "$REQUIREMENTS_PATH" ]; then
    if [ "$USE_UV" = "true" ]; then
      if [ "$NO_CACHE" = "true" ]; then
        ohai "Installing dependencies using 'uv pip sync --no-cache --link-mode=copy $REQUIREMENTS_PATH'"
        uv pip sync --no-cache --link-mode=copy "$REQUIREMENTS_PATH"
      else
        ohai "Installing dependencies using 'uv pip sync --link-mode=copy $REQUIREMENTS_PATH'"
        uv pip sync --link-mode=copy "$REQUIREMENTS_PATH"
      fi
    else
      ohai "Installing dependencies using 'python -m pip install $PIP_INSTALL_OPTIONS -r \"$REQUIREMENTS_PATH\"'"
      python -m pip install $PIP_INSTALL_OPTIONS -r "$REQUIREMENTS_PATH"
    fi
  else
    info "No dependencies to install (requirements file $REQUIREMENTS_PATH is empty or not found)."
  fi
else
  # Filter dependencies based on what's provided by modules
  if [ -s "$MODULE_PACKAGES_FILE" ]; then
    ohai "Filtering requirements against module-provided packages"
    FILTERED_REQUIREMENTS=$(mktemp)
    EXCLUDED_COUNT=0
    INSTALLED_COUNT=0

    # Process each line in the requirements file - more efficient single pass
    if [ -s "$REQUIREMENTS_PATH" ]; then
      # Use grep to filter out comments and empty lines first
      grep -v "^[[:space:]]*#" "$REQUIREMENTS_PATH" | grep -v "^[[:space:]]*$" | while read -r line; do
        # Extract package name without version specs
        package_name=$(echo "$line" | sed 's/[^a-zA-Z0-9_.-].*//' | tr '[:upper:]' '[:lower:]')

        # Check if package exists in module packages (now just the name)
        if grep -i -q "^${package_name}$" "$MODULE_PACKAGES_FILE"; then
          info "Excluding '$line' (provided by loaded modules)"
          EXCLUDED_COUNT=$((EXCLUDED_COUNT + 1))
        else
          # Package not provided by modules, add to filtered list
          echo "$line" >> "$FILTERED_REQUIREMENTS"
          INSTALLED_COUNT=$((INSTALLED_COUNT + 1))
        fi
      done
    else
      info "Requirements file '$REQUIREMENTS_PATH' is empty or not found, so no packages to filter from it."
    fi

    # Install the filtered dependencies
    ohai "Installing $INSTALLED_COUNT package(s) from filtered requirements ($EXCLUDED_COUNT excluded due to module conflicts)"
    if [ -s "$FILTERED_REQUIREMENTS" ]; then
      if [ "$USE_UV" = "true" ]; then
        if [ "$NO_CACHE" = "true" ]; then
          ohai "Installing filtered dependencies using 'uv pip install --no-cache --link-mode=copy -r \"$FILTERED_REQUIREMENTS\"'"
          uv pip install --no-cache --link-mode=copy -r "$FILTERED_REQUIREMENTS"
        else
          ohai "Installing filtered dependencies using 'uv pip install --link-mode=copy -r \"$FILTERED_REQUIREMENTS\"'"
          uv pip install --link-mode=copy -r "$FILTERED_REQUIREMENTS"
        fi
      else
        ohai "Installing filtered dependencies using 'python -m pip install $PIP_INSTALL_OPTIONS -r \"$FILTERED_REQUIREMENTS\"'"
        python -m pip install $PIP_INSTALL_OPTIONS -r "$FILTERED_REQUIREMENTS"
      fi
    else
      info "No additional packages need to be installed (after filtering against module packages)."
    fi
    # Clean up temp file
    rm -f "$FILTERED_REQUIREMENTS"
  else
    # No module packages detected (or MODULE_PACKAGES_FILE was empty), so install directly from REQUIREMENTS_PATH
    ohai "No module packages to filter against, or module package list was empty."
    ohai "Installing all dependencies directly from $REQUIREMENTS_PATH"
    if [ -s "$REQUIREMENTS_PATH" ]; then
      if [ "$USE_UV" = "true" ]; then
        if [ "$NO_CACHE" = "true" ]; then
          ohai "Installing dependencies using 'uv pip sync --no-cache --link-mode=copy $REQUIREMENTS_PATH'"
          uv pip sync --no-cache --link-mode=copy "$REQUIREMENTS_PATH"
        else
          ohai "Installing dependencies using 'uv pip sync --link-mode=copy $REQUIREMENTS_PATH'"
          uv pip sync --link-mode=copy "$REQUIREMENTS_PATH"
        fi
      else
        ohai "Installing dependencies using 'python -m pip install $PIP_INSTALL_OPTIONS -r \"$REQUIREMENTS_PATH\"'"
        python -m pip install $PIP_INSTALL_OPTIONS -r "$REQUIREMENTS_PATH"
      fi
    else
      info "No dependencies to install (requirements file $REQUIREMENTS_PATH is empty or not found)."
    fi
  fi
fi


# Clean up any temporary files
rm -f "$MODULE_PACKAGES_FILE" 2>/dev/null || true

# Handle development mode install if enabled
if [ "$DEV_MODE" = "true" ]; then
  ohai "Step 4.5: Installing current directory as an editable package"

  if [ -f "setup.py" ] || [ -f "pyproject.toml" ]; then
    info "Found Python package configuration in current directory"
    if [ "$USE_UV" = "true" ]; then
      if [ "$NO_CACHE" = "true" ]; then
        ohai "Installing current directory as editable package using 'uv pip install --no-cache --link-mode=copy --editable .'"
        # For uv, --no-build-isolation is generally not needed as it handles builds differently.
        # We are not passing $PIP_INSTALL_OPTIONS to uv for editable install.
        # Not using --reinstall to ensure dependencies are only installed if missing/incompatible.
        uv pip install --no-cache --link-mode=copy --editable . || {
          warn "Failed to install current directory as editable package using uv"
          warn "Check that your setup.py or pyproject.toml is valid"
        }
      else
        ohai "Installing current directory as editable package using 'uv pip install --link-mode=copy --editable .'"
        uv pip install --link-mode=copy --editable . || {
          warn "Failed to install current directory as editable package using uv"
          warn "Check that your setup.py or pyproject.toml is valid"
        }
      fi
    else
      ohai "Installing current directory as editable package using 'python -m pip install $PIP_INSTALL_OPTIONS --no-build-isolation --editable .'"
      python -m pip install $PIP_INSTALL_OPTIONS --no-build-isolation --editable . || {
        warn "Failed to install current directory as editable package using pip"
        warn "Check that your setup.py or pyproject.toml is valid"
      }
    fi
    success "Installed current directory as editable package"
  else
    warn "No setup.py or pyproject.toml found in current directory"
    warn "Skipping editable install. Create one of these files if needed."
  fi
fi

# Re-enable .pyc file generation if it was set
if [ -n "$PYTHONDONTWRITEBYTECODE" ]; then
  ohai "Re-enabling .pyc file generation"
  unset PYTHONDONTWRITEBYTECODE
fi

# Run custom setup commands if provided
@@CUSTOM_SETUP_COMMANDS_BLOCK@@

success "Setup completed successfully for Environment '@@ENV_NAME@@'"
success "To activate, run: source $(realpath @@ACTIVATE_SCRIPT_PATH@@)"
success "Or from anywhere: source \$(zenv activate @@ENV_NAME@@)"
success "Setup log has been written to $LOG_FILE"

# Add final marker in the log file
echo "=== Setup script completed at $(date) ===" >> "$LOG_FILE"
