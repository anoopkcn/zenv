#!/bin/sh
set -e # Exit on error for setup scripts

# Setup script for '@@ENV_NAME@@' environment generated by zenv

# Define a function to handle module errors
handle_module_error() {
  echo "Error: Failed to load module '$1'" >&2
  exit 1
}

# Handle force_rebuild flag
@@FORCE_REBUILD_VALUE@@
if [ "$FORCE_REBUILD" = "true" ]; then
  echo '==> Force rebuild flag (--rebuild) detected'
  echo '==> Will recreate the virtual environment if it exists'
else
  echo '==> Normal setup mode (use --rebuild to force recreation)'
fi

# Check if module command exists
if command -v module >/dev/null 2>&1; then
  echo '==> Purging all modules'
  module --force purge

  # Load all required modules first
  @@MODULE_LOADING_BLOCK@@

  # After loading modules, check which Python is now available in the PATH
  MODULE_PYTHON=""
  if command -v python3 >/dev/null 2>&1; then
    MODULE_PYTHON=$(which python3)
    echo "==> Found Python in PATH after loading modules: $MODULE_PYTHON"
    echo "==> Version: $($MODULE_PYTHON --version 2>&1)"
  elif command -v python >/dev/null 2>&1; then
    MODULE_PYTHON=$(which python)
    echo "==> Found Python in PATH after loading modules: $MODULE_PYTHON"
    echo "==> Version: $($MODULE_PYTHON --version 2>&1)"
  else
    echo "==> WARNING: No Python found in PATH after loading modules."
    if [ -n "@@FALLBACK_PYTHON@@" ] && [ "@@FALLBACK_PYTHON@@" != "python3" ]; then
      echo "==> Will try fallback Python: @@FALLBACK_PYTHON@@"
    else
      echo "==> Will try system Python executables"
    fi
  fi

  echo '==> Checking Python packages provided by modules'
  MODULE_PACKAGES_FILE=$(mktemp)
  # Use module Python if available, otherwise try system Python
  if [ -n "$MODULE_PYTHON" ]; then
    $MODULE_PYTHON -m pip list --format=freeze > "$MODULE_PACKAGES_FILE" 2>/dev/null || true
  else
    (python3 -m pip list --format=freeze > "$MODULE_PACKAGES_FILE" 2>/dev/null || python -m pip list --format=freeze > "$MODULE_PACKAGES_FILE" 2>/dev/null) || true
  fi

  if [ -s "$MODULE_PACKAGES_FILE" ]; then
    echo '==> Found packages from modules:'
    echo -n '    '
    # Extract just package names, sort, join with comma-space
    cat "$MODULE_PACKAGES_FILE" | sed -E 's/==.*//;s/ .*//' | sort | tr '\n' ',' | sed 's/,/, /g' | sed 's/, $//'
    echo ''
  else
    echo '==> No Python packages detected from modules'
    # Ensure the file exists even if empty for later steps
    touch "$MODULE_PACKAGES_FILE"
  fi
else
  echo '==> Module command not found, skipping module operations'
  MODULE_PACKAGES_FILE=$(mktemp) # Create empty temp file
  MODULE_PYTHON="" # Ensure this is empty when no modules are loaded
fi

echo '==> Step 3: Creating Python virtual environment'

# Check if virtual environment already exists and is valid
REBUILD_VENV=false
FRESH_SETUP=false
if [ -d "@@VENV_DIR@@" ]; then
  # Check if the directory has any content other than our own setup files
  DIR_FILES=$(find "@@VENV_DIR@@" -mindepth 1 -not -name "setup_env.sh" -not -name "requirements.txt" | wc -l)

  if [ "$DIR_FILES" -eq 0 ]; then
    # Directory exists but is empty (fresh setup)
    echo "==> Setting up new virtual environment in existing directory"
    FRESH_SETUP=true
  elif [ -f "@@VENV_DIR@@/bin/activate" ] && [ -f "@@VENV_DIR@@/bin/python" ]; then
    echo "==> Virtual environment already exists and appears valid"

    # Only rebuild if explicitly requested with --rebuild flag
    if [ "$FORCE_REBUILD" = "true" ]; then
      echo "==> Rebuild flag detected, recreating virtual environment"
      REBUILD_VENV=true
      rm -rf "@@VENV_DIR@@"/*
    else
      # If we have Python from modules, show info but don't automatically rebuild
      if [ -n "$MODULE_PYTHON" ]; then
        VENV_PYTHON="@@VENV_DIR@@/bin/python"
        VENV_PYTHON_VERSION=$($VENV_PYTHON --version 2>&1)
        MODULE_PYTHON_VERSION=$($MODULE_PYTHON --version 2>&1)

        echo "==> Current environment Python: $VENV_PYTHON_VERSION ($VENV_PYTHON)"
        echo "==> Available module Python: $MODULE_PYTHON_VERSION ($MODULE_PYTHON)"

        if [ "$MODULE_PYTHON_VERSION" != "$VENV_PYTHON_VERSION" ]; then
          echo "==> NOTE: Module-provided Python differs from environment Python"
          echo "==>       Use --rebuild flag if you want to recreate using module-provided Python"
        else
          echo "==> Python versions match, keeping existing environment"
        fi
      fi
    fi
  else
    echo "==> Virtual environment directory exists but appears corrupted or incomplete"
    echo "==> Rebuilding virtual environment"
    REBUILD_VENV=true
    rm -rf "@@VENV_DIR@@"/*
  fi
fi

# Create virtual environment if it doesn't exist or needs to be rebuilt
if [ ! -d "@@VENV_DIR@@" ] || [ "$REBUILD_VENV" = "true" ] || [ "$FRESH_SETUP" = "true" ]; then
  # Try Python in this order of preference:
  # 1. Python from modules/PATH after loading modules
  # 2. Configured Python from config file
  # 3. python3 in PATH
  # 4. python in PATH
  VENV_CREATED=false

  # 1. If we found Python after loading modules, use it first
  if [ -n "$MODULE_PYTHON" ]; then
    echo "==> Creating virtual environment with module-provided Python"
    echo "==>   Executable: $MODULE_PYTHON"

    # Check if Python supports venv
    if ! $MODULE_PYTHON -c "import venv" 2>/dev/null; then
      echo "==> WARNING: The module-provided Python does not support venv module"
      echo "==>          Will try alternative Python executables"
    else
      $MODULE_PYTHON -m venv @@VENV_DIR@@ && VENV_CREATED=true
      if [ "$VENV_CREATED" = true ]; then
        echo "==> Successfully created virtual environment using module-provided Python"
        if [ -n "@@FALLBACK_PYTHON@@" ] && [ "@@FALLBACK_PYTHON@@" != "python3" ]; then
          echo "==>   (Fallback Python '@@FALLBACK_PYTHON@@' was not used)"
        fi
      fi
    fi
  fi

  # 2. Then try fallback Python if module Python didn't work or isn't available
  if [ "$VENV_CREATED" = false ] && command -v @@FALLBACK_PYTHON@@ >/dev/null 2>&1; then
    if [ -n "$MODULE_PYTHON" ]; then
      echo "==> Module-provided Python failed to create venv, trying fallback Python"
    else
      echo "==> No module Python available, using fallback Python"
    fi
    echo "==>   Executable: @@FALLBACK_PYTHON@@"
    echo "==>   Version: $(@@FALLBACK_PYTHON@@ --version 2>&1)"

    @@FALLBACK_PYTHON@@ -m venv @@VENV_DIR@@ && VENV_CREATED=true
    if [ "$VENV_CREATED" = true ]; then
      echo "==> Successfully created virtual environment using fallback Python"
    fi
  fi

  # 3. Fallback to standard python3
  if [ "$VENV_CREATED" = false ] && command -v python3 >/dev/null 2>&1; then
    echo "==> Previous Python options unavailable, falling back to system 'python3'"
    echo "==>   Executable: $(which python3)"
    echo "==>   Version: $(python3 --version 2>&1)"

    python3 -m venv @@VENV_DIR@@ && VENV_CREATED=true
    if [ "$VENV_CREATED" = true ]; then
      echo "==> Successfully created virtual environment using system python3"
    fi
  fi

  # 4. Last resort - try python
  if [ "$VENV_CREATED" = false ] && command -v python >/dev/null 2>&1; then
    echo "==> Last resort: falling back to system 'python'"
    echo "==>   Executable: $(which python)"
    echo "==>   Version: $(python --version 2>&1)"

    python -m venv @@VENV_DIR@@ && VENV_CREATED=true
    if [ "$VENV_CREATED" = true ]; then
      echo "==> Successfully created virtual environment using system python"
    fi
  fi

  if [ "$VENV_CREATED" = false ]; then
    echo "ERROR: Failed to find a suitable Python executable to create venv."
    echo "Please ensure at least one of the following is available:"
    echo "  - Python provided by loaded modules"
    echo "  - Fallback Python (@@FALLBACK_PYTHON@@)"
    echo "  - System python3 or python with venv module"
    exit 1
  fi
else
  echo "==> Using existing virtual environment"
fi

echo '==> Step 4: Activating environment and installing dependencies'
# Print out the exact paths we're trying to use for debugging
echo "Virtual environment directory: @@VENV_DIR@@"
echo "Looking for activate script at: @@VENV_DIR@@/bin/activate"

# Check if the directory exists
if [ ! -d "@@VENV_DIR@@" ]; then
  echo "ERROR: Virtual environment directory does not exist at @@VENV_DIR@@"
  echo "This could indicate a path issue in the setup script."
  exit 1
fi

# Make sure the activate script exists
if [ ! -f "@@VENV_DIR@@/bin/activate" ]; then
  echo "ERROR: Virtual environment activation script not found at @@VENV_DIR@@/bin/activate"
  if [ -d "@@VENV_DIR@@/bin" ]; then
    echo "bin directory contents:"
    ls -la "@@VENV_DIR@@/bin"
  else
    echo "bin directory does not exist in @@VENV_DIR@@"
  fi
  echo "This could indicate that the virtual environment was not created properly."
  exit 1
fi

# For the setup script, we use the standard bin/activate
# (The custom activate.sh is only for user activation)
source "@@VENV_DIR@@/bin/activate"

# Ensure pip is available and upgrade it
if ! python -m pip --version >/dev/null 2>&1; then
  echo "ERROR: 'pip' module not found after activating venv. Ensure Python installation includes pip."
  exit 1
fi
python -m pip install --upgrade pip

# Handle dependencies installation based on force_deps flag
@@FORCE_DEPS_VALUE@@

# Check if requirements file exists and has content
if [ -f "@@REQUIREMENTS_PATH@@" ]; then
  echo "Requirements file exists at @@REQUIREMENTS_PATH@@"
  if [ -s "@@REQUIREMENTS_PATH@@" ]; then
    # echo "Requirements file is not empty"
    # echo "File content:"
    # cat "@@REQUIREMENTS_PATH@@"
    REQUIREMENTS_PATH="@@REQUIREMENTS_PATH@@"
  else
    echo "Requirements file exists but is empty, checking for alternative"
    if [ -f "$(dirname "@@VENV_DIR@@")/requirements.txt" ] && [ -s "$(dirname "@@VENV_DIR@@")/requirements.txt" ]; then
      echo "Found non-empty alternative requirements file in environment directory"
      REQUIREMENTS_PATH="$(dirname "@@VENV_DIR@@")/requirements.txt"
      echo "Using alternative requirements file: $REQUIREMENTS_PATH"
      echo "File content:"
      cat "$REQUIREMENTS_PATH"
    else
      echo "Creating empty requirements file"
      touch "@@REQUIREMENTS_PATH@@"
      REQUIREMENTS_PATH="@@REQUIREMENTS_PATH@@"
    fi
  fi
else
  echo "Warning: Requirements file not found at @@REQUIREMENTS_PATH@@"
  if [ -f "$(dirname "@@VENV_DIR@@")/requirements.txt" ] && [ -s "$(dirname "@@VENV_DIR@@")/requirements.txt" ]; then
    echo "Found alternative requirements file in environment directory"
    REQUIREMENTS_PATH="$(dirname "@@VENV_DIR@@")/requirements.txt"
    echo "Using alternative requirements file: $REQUIREMENTS_PATH"
    # echo "File content:"
    # cat "$REQUIREMENTS_PATH"
  else
    echo "Creating empty requirements file"
    touch "@@REQUIREMENTS_PATH@@"
    REQUIREMENTS_PATH="@@REQUIREMENTS_PATH@@"
  fi
fi

if [ "$FORCE_DEPS" = "true" ]; then
  # Install all dependencies regardless of module packages
  echo '==> Using --force-deps: Installing all specified dependencies'
  if [ -f "$REQUIREMENTS_PATH" ] && [ -s "$REQUIREMENTS_PATH" ]; then
    python -m pip install -r "$REQUIREMENTS_PATH"
  else
    echo '==> No requirements file found or file is empty. Skipping package installation.'
  fi
  rm -f "$MODULE_PACKAGES_FILE" 2>/dev/null || true
else
  # Filter dependencies based on what's provided by modules
  if [ -n "$MODULE_PACKAGES_FILE" ] && [ -s "$MODULE_PACKAGES_FILE" ]; then
    echo '==> Filtering requirements against module-provided packages'
    FILTERED_REQUIREMENTS=$(mktemp)
    EXCLUDED_COUNT=0
    INSTALLED_COUNT=0

    # Process each line in the requirements file
    if [ -s "$REQUIREMENTS_PATH" ]; then
      while IFS= read -r line || [ -n "$line" ]; do
        # Skip comments and empty lines
        trimmed_line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        if [ -z "$trimmed_line" ] || [[ "$trimmed_line" == "#"* ]]; then
          continue
        fi

        # Extract package name without version specs
        package_name=$(echo "$trimmed_line" | sed 's/[^a-zA-Z0-9_.-].*//' | tr '[:upper:]' '[:lower:]')

        # Check if package exists in module packages
        if grep -i -q "^${package_name}==" "$MODULE_PACKAGES_FILE" || grep -i -q "^${package_name} " "$MODULE_PACKAGES_FILE"; then
          echo "==> Excluding '$trimmed_line' (provided by loaded modules)"
          EXCLUDED_COUNT=$((EXCLUDED_COUNT + 1))
        else
          # Package not provided by modules, add to filtered list
          echo "$line" >> "$FILTERED_REQUIREMENTS"
          INSTALLED_COUNT=$((INSTALLED_COUNT + 1))
        fi
      done < "$REQUIREMENTS_PATH"
    else
      echo "==> Requirements file is empty or not readable"
    fi

    # Install the filtered dependencies
    echo "==> Installing $INSTALLED_COUNT package(s) from filtered requirements ($EXCLUDED_COUNT excluded)"
    if [ -f "$FILTERED_REQUIREMENTS" ] && [ -s "$FILTERED_REQUIREMENTS" ]; then
      python -m pip install -r "$FILTERED_REQUIREMENTS"
    else
      echo '==> No additional packages need to be installed'
    fi

    # Clean up temp files
    rm -f "$FILTERED_REQUIREMENTS" "$MODULE_PACKAGES_FILE"
  else
    # No module packages detected, install all requirements
    echo '==> Installing all dependencies from requirements file'
    if [ -f "$REQUIREMENTS_PATH" ] && [ -s "$REQUIREMENTS_PATH" ]; then
      python -m pip install -r "$REQUIREMENTS_PATH"
    else
      echo '==> No requirements file found or file is empty. Skipping package installation.'
    fi
    rm -f "$MODULE_PACKAGES_FILE" 2>/dev/null || true
  fi
fi

# Run custom setup commands if provided
@@CUSTOM_SETUP_COMMANDS_BLOCK@@

echo '==> Setup completed successfully for Environment '@@ENV_NAME@@' '
echo "To activate, run: source $(realpath @@ACTIVATE_SCRIPT_PATH@@)"
echo "Or from anywhere: source $(zenv activate @@ENV_NAME@@)"
