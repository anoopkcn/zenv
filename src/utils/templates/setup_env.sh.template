#!/bin/sh
set -e # Exit on error for setup scripts

# Setup script for '@@ENV_NAME@@' environment generated by zenv

# Print message in blue
ohai() {
  printf '\033[0;34minfo:\033[0;39m %s\033[0m\n' "$@"
}

# Print message in green
success() {
  printf '\033[1;32minfo:\033[1;39m %s\033[0m\n' "$@"
}

# Print message in yellow
info() {
  printf '\033[1;33minfo:\033[0m %s\n' "$@"
}

# Print warning message in red
warn() {
  printf '\033[1;31mWarning:\033[0m: %s\n' "$@" >&2
}

# Print error message and exit
abort() {
  printf '\033[1;31mError:\033[0m: %s\n' "$@" >&2
  exit 1
}

# Define a function to handle module errors
handle_module_error() {
  abort "Failed to load module '$1'"
}

# Handle force_rebuild flag
@@FORCE_REBUILD_VALUE@@
if [ "$FORCE_REBUILD" = "true" ]; then
  ohai "Force rebuild flag (--rebuild) detected"
  info "Will recreate the virtual environment if it exists"
else
  ohai "Normal setup mode"
fi

# Handle use_default_python flag
@@USE_DEFAULT_PYTHON_VALUE@@
if [ "$USE_DEFAULT_PYTHON" = "true" ]; then
  ohai "Python flag (--python) detected"
  info "Will use only the default Python from ZENV_DIR/default-python"
fi

# Handle development mode flag
@@DEV_MODE_VALUE@@
if [ "$DEV_MODE" = "true" ]; then
  ohai "Development mode flag (--dev) detected"
  info "Will install current directory as an editable package"
fi

# Handle modules_verified flag
@@MODULES_VERIFIED_VALUE@@

# Check if module command exists
if command -v module >/dev/null 2>&1; then
  ohai "Purging all modules"
  module --force purge

  # Load modules based on verification status
  if [ "$MODULES_VERIFIED" = "true" ]; then
    # ohai "Modules were pre-verified, proceeding with loading"
    # We still need to load the modules to access the Python they provide
    # But if any fails, we'll continue since we verified they should work
    @@MODULE_LOADING_BLOCK@@
  else
    # Load all required modules with full error checking
    @@MODULE_LOADING_BLOCK@@
  fi

  # After loading modules, check which Python is now available in the PATH
  MODULE_PYTHON=""
  if command -v python3 >/dev/null 2>&1; then
    MODULE_PYTHON=$(which python3)
    ohai "Found Python in PATH after loading modules: $MODULE_PYTHON"
    info "Version: $($MODULE_PYTHON --version 2>&1)"
  elif command -v python >/dev/null 2>&1; then
    MODULE_PYTHON=$(which python)
    ohai "Found Python in PATH after loading modules: $MODULE_PYTHON"
    info "Version: $($MODULE_PYTHON --version 2>&1)"
  else
    warn "No Python found in PATH after loading modules."
    if [ -n "@@FALLBACK_PYTHON@@" ] && [ "@@FALLBACK_PYTHON@@" != "python3" ]; then
      info "Will try fallback Python: @@FALLBACK_PYTHON@@"
    else
      info "Will try system Python executables"
    fi
  fi

  ohai "Checking Python packages provided by modules"
  MODULE_PACKAGES_FILE=$(mktemp)
  # Use module Python if available, otherwise try system Python
  # Extract and preprocess package names for faster filtering
  if [ -n "$MODULE_PYTHON" ]; then
    $MODULE_PYTHON -m pip list --format=freeze | awk -F'==' '{print $1}' | sort > "$MODULE_PACKAGES_FILE" 2>/dev/null || true
  else
    (python3 -m pip list --format=freeze | awk -F'==' '{print $1}' | sort > "$MODULE_PACKAGES_FILE" 2>/dev/null || python -m pip list --format=freeze | awk -F'==' '{print $1}' | sort > "$MODULE_PACKAGES_FILE" 2>/dev/null) || true
  fi

  if [ -s "$MODULE_PACKAGES_FILE" ]; then
    ohai "Found packages from modules:"
    echo -n '    '
    # Extract just package names, sort, join with comma-space
    cat "$MODULE_PACKAGES_FILE" | sed -E 's/==.*//;s/ .*//' | sort | tr '\n' ',' | sed 's/,/, /g' | sed 's/, $//'
    echo ''
  else
    ohai "No Python packages detected from modules"
    # Ensure the file exists even if empty for later steps
    touch "$MODULE_PACKAGES_FILE"
  fi
else
  ohai "Module command not found, skipping module operations"
  MODULE_PACKAGES_FILE=$(mktemp) # Create empty temp file
  MODULE_PYTHON="" # Ensure this is empty when no modules are loaded
fi

ohai "Step 3: Creating Python virtual environment"

# Check if virtual environment already exists and is valid
REBUILD_VENV=false
FRESH_SETUP=false
if [ -d "@@VENV_DIR@@" ]; then
  # Check if the directory has any content other than our own setup files
  DIR_FILES=$(find "@@VENV_DIR@@" -mindepth 1 -not -name "setup_env.sh" -not -name "requirements.txt" | wc -l)

  if [ "$DIR_FILES" -eq 0 ]; then
    # Directory exists but is empty (fresh setup)
    ohai "Setting up new virtual environment in existing directory"
    FRESH_SETUP=true
  elif [ -f "@@VENV_DIR@@/bin/activate" ] && [ -f "@@VENV_DIR@@/bin/python" ]; then
    ohai "Virtual environment already exists and appears valid"

    # Only rebuild if explicitly requested with --rebuild flag
    if [ "$FORCE_REBUILD" = "true" ]; then
      ohai "Rebuild flag detected, recreating virtual environment"
      REBUILD_VENV=true
      rm -rf "@@VENV_DIR@@"/*
    else
      # If we have Python from modules, show info but don't automatically rebuild
      if [ -n "$MODULE_PYTHON" ]; then
        VENV_PYTHON="@@VENV_DIR@@/bin/python"
        VENV_PYTHON_VERSION=$($VENV_PYTHON --version 2>&1)
        MODULE_PYTHON_VERSION=$($MODULE_PYTHON --version 2>&1)

        ohai "Current environment Python: $VENV_PYTHON_VERSION ($VENV_PYTHON)"
        ohai "Available module Python: $MODULE_PYTHON_VERSION ($MODULE_PYTHON)"

        if [ "$MODULE_PYTHON_VERSION" != "$VENV_PYTHON_VERSION" ]; then
          warn "Module-provided Python differs from environment Python"
          info "Use --rebuild flag if you want to recreate using module-provided Python"
        else
          success "Python versions match, keeping existing environment"
        fi
      fi
    fi
  else
    info "Virtual environment directory exists but appears corrupted or incomplete"
    ohai "Rebuilding virtual environment"
    REBUILD_VENV=true
    rm -rf "@@VENV_DIR@@"/*
  fi
fi

# Create virtual environment if it doesn't exist or needs to be rebuilt
if [ ! -d "@@VENV_DIR@@" ] || [ "$REBUILD_VENV" = "true" ] || [ "$FRESH_SETUP" = "true" ]; then
  # Function to create virtual environment with a specific Python
  create_venv() {
    local python_exe="$1"
    local description="$2"
    if [ -n "$python_exe" ] && command -v "$python_exe" >/dev/null 2>&1; then
      ohai "Creating virtual environment with $description"
      info "Executable: $(which "$python_exe")"
      info "Version: $("$python_exe" --version 2>&1)"

      # Check if Python supports venv
      if ! "$python_exe" -c "import venv" 2>/dev/null; then
        warn "$description does not support venv module"
        return 1
      fi

      "$python_exe" -m venv "@@VENV_DIR@@" && return 0
    fi
    return 1
  }

  VENV_CREATED=false

  # When --python flag is used, only use the default Python
  if [ "$USE_DEFAULT_PYTHON" = "true" ]; then
    if [ -n "@@FALLBACK_PYTHON@@" ] && [ "@@FALLBACK_PYTHON@@" != "python3" ]; then
      create_venv "@@FALLBACK_PYTHON@@" "default configured Python" && VENV_CREATED=true &&
      success "Successfully created virtual environment using default Python"
    else
      abort "Default Python not found but --python flag was specified.\nUse 'zenv python use <version>' to set a default Python first."
    fi
  else
    # Try various Python interpreters in order of preference
    if [ -n "$MODULE_PYTHON" ]; then
      create_venv "$MODULE_PYTHON" "module-provided Python" && VENV_CREATED=true &&
      success "Successfully prepared virtual environment using module-provided Python"
    fi

    if [ "$VENV_CREATED" = "false" ]; then
      # Check if this is a custom Python path (potentially from zenv python install)
      if [ -n "@@FALLBACK_PYTHON@@" ] && [ "@@FALLBACK_PYTHON@@" != "python3" ]; then
        if [[ "@@FALLBACK_PYTHON@@" == *".zenv/python/"* ]]; then
          # This is a zenv managed Python
          version=$(basename $(dirname $(dirname "@@FALLBACK_PYTHON@@")))
          ohai "Using zenv-managed Python $version"
        else
          # This is a user-specified fallback Python
          ohai "Using fallback Python: @@FALLBACK_PYTHON@@"
        fi
        create_venv "@@FALLBACK_PYTHON@@" "fallback Python" && VENV_CREATED=true &&
        success "Successfully created virtual environment using fallback Python"
      else
        # Fall back to system Python
        create_venv "python3" "system python3" && VENV_CREATED=true &&
        success "Successfully created virtual environment using system python3"
      fi
    fi

    if [ "$VENV_CREATED" = "false" ]; then
      create_venv "python" "system python" && VENV_CREATED=true &&
      success "Successfully created virtual environment using system python"
    fi
  fi

  if [ "$VENV_CREATED" = "false" ]; then
    abort "Failed to find a suitable Python executable to create venv.
Please ensure at least one of the following is available:
  - Python provided by loaded modules
  - Fallback Python (@@FALLBACK_PYTHON@@)
  - System python3 or python with venv module"
  fi
else
  ohai "Using existing virtual environment"
fi

ohai "Step 4: Activating environment and installing dependencies"
# Verify the virtual environment exists and is valid
if [ ! -d "@@VENV_DIR@@" ] || [ ! -f "@@VENV_DIR@@/bin/activate" ]; then
  abort "Virtual environment not found or invalid at @@VENV_DIR@@
$(if [ -d "@@VENV_DIR@@" ] && [ ! -d "@@VENV_DIR@@/bin" ]; then
  echo "bin directory does not exist in @@VENV_DIR@@"
elif [ -d "@@VENV_DIR@@/bin" ]; then
  echo "bin directory contents:"
  ls -la "@@VENV_DIR@@/bin"
fi)
This could indicate that the virtual environment was not created properly."
fi

# Activate the environment
source "@@VENV_DIR@@/bin/activate"

# Ensure pip is available and upgrade it
if ! python -m pip --version >/dev/null 2>&1; then
  abort "'pip' module not found after activating venv. Ensure Python installation includes pip."
fi
ohai "Upgrading pip to latest version"
python -m pip install --ignore-installed --no-build-isolation --upgrade pip

# Check for cached packages in ZENV_DIR
PACKAGE_CACHE=""
if [ -n "$HOME" ]; then
  ZENV_DIR="${HOME}/.zenv"
  if [ -d "$ZENV_DIR/packages/files" ]; then
    ohai "Found package cache at $ZENV_DIR/packages/files"
    PACKAGE_CACHE="--find-links $ZENV_DIR/packages/files"
    info "Will try cached packages before downloading from internet"
  fi
fi

# Handle dependencies installation based on force_deps flag
@@FORCE_DEPS_VALUE@@

# Resolve requirements file path
REQUIREMENTS_PATH="@@REQUIREMENTS_PATH@@"
if [ ! -f "$REQUIREMENTS_PATH" ] || [ ! -s "$REQUIREMENTS_PATH" ]; then
  # Primary requirements file doesn't exist or is empty
  ALT_REQUIREMENTS="$(dirname "@@VENV_DIR@@")/requirements.txt"
  if [ -f "$ALT_REQUIREMENTS" ] && [ -s "$ALT_REQUIREMENTS" ]; then
    ohai "Using alternative requirements file: $ALT_REQUIREMENTS"
    REQUIREMENTS_PATH="$ALT_REQUIREMENTS"
  else
    # Create empty requirements file if none exists
    info "No valid requirements file found. Creating empty one."
    touch "@@REQUIREMENTS_PATH@@"
    REQUIREMENTS_PATH="@@REQUIREMENTS_PATH@@"
  fi
fi

# Install dependencies
if [ "$FORCE_DEPS" = "true" ]; then
  # Install all dependencies regardless of module packages
  ohai "Using --force-deps: Installing all specified dependencies"
  if [ -s "$REQUIREMENTS_PATH" ]; then
    # Use --ignore-installed to prevent pip from attempting to uninstall module packages
    # and --no-build-isolation for faster installation
    ohai "Using --ignore-installed and --no-build-isolation for faster installation"
    python -m pip install --ignore-installed --no-build-isolation $PACKAGE_CACHE -r "$REQUIREMENTS_PATH"
  else
    info "No dependencies to install (empty requirements file)"
  fi
else
  # Filter dependencies based on what's provided by modules
  if [ -s "$MODULE_PACKAGES_FILE" ]; then
    ohai "Filtering requirements against module-provided packages"
    FILTERED_REQUIREMENTS=$(mktemp)
    EXCLUDED_COUNT=0
    INSTALLED_COUNT=0

    # Process each line in the requirements file - more efficient single pass
    if [ -s "$REQUIREMENTS_PATH" ]; then
      # Use grep to filter out comments and empty lines first
      grep -v "^[[:space:]]*#" "$REQUIREMENTS_PATH" | grep -v "^[[:space:]]*$" | while read -r line; do
        # Extract package name without version specs
        package_name=$(echo "$line" | sed 's/[^a-zA-Z0-9_.-].*//' | tr '[:upper:]' '[:lower:]')

        # Check if package exists in module packages (now just the name)
        if grep -i -q "^${package_name}$" "$MODULE_PACKAGES_FILE"; then
          info "Excluding '$line' (provided by loaded modules)"
          EXCLUDED_COUNT=$((EXCLUDED_COUNT + 1))
        else
          # Package not provided by modules, add to filtered list
          echo "$line" >> "$FILTERED_REQUIREMENTS"
          INSTALLED_COUNT=$((INSTALLED_COUNT + 1))
        fi
      done
    else
      info "Requirements file is empty or not readable"
    fi

    # Install the filtered dependencies
    ohai "Installing $INSTALLED_COUNT package(s) from filtered requirements ($EXCLUDED_COUNT excluded)"
    if [ -s "$FILTERED_REQUIREMENTS" ]; then
      # Use --ignore-installed to prevent pip from attempting to uninstall module packages
      # and --no-build-isolation for faster installation
      ohai "Using --ignore-installed and --no-build-isolation for faster installation"
      python -m pip install --ignore-installed --no-build-isolation $PACKAGE_CACHE -r "$FILTERED_REQUIREMENTS"
    else
      info "No additional packages need to be installed"
    fi

    # Clean up temp file
    rm -f "$FILTERED_REQUIREMENTS"
  else
    # No module packages detected, install all requirements
    ohai "Installing all dependencies from requirements file"
    if [ -s "$REQUIREMENTS_PATH" ]; then
      # No module packages detected, but still use --ignore-installed for consistency
      # and --no-build-isolation for faster installation
      python -m pip install --ignore-installed --no-build-isolation $PACKAGE_CACHE -r "$REQUIREMENTS_PATH"
    else
      info "No dependencies to install (empty requirements file)"
    fi
  fi
fi

# Clean up any temporary files
rm -f "$MODULE_PACKAGES_FILE" 2>/dev/null || true

# Handle development mode install if enabled
if [ "$DEV_MODE" = "true" ]; then
  ohai "Step 4.5: Installing current directory as an editable package"

  # Verify that setup.py or pyproject.toml exists
  if [ -f "setup.py" ] || [ -f "pyproject.toml" ]; then
    info "Found Python package configuration in current directory"
    python -m pip install --ignore-installed --no-build-isolation $PACKAGE_CACHE --editable . || {
      warn "Failed to install current directory as editable package"
      warn "Check that your setup.py or pyproject.toml is valid"
    }
    success "Installed current directory as editable package"
  else
    warn "No setup.py or pyproject.toml found in current directory"
    warn "Skipping editable install. Create one of these files if needed."
  fi
fi

# Run custom setup commands if provided
@@CUSTOM_SETUP_COMMANDS_BLOCK@@

success "Setup completed successfully for Environment '@@ENV_NAME@@'"
success "To activate, run: source $(realpath @@ACTIVATE_SCRIPT_PATH@@)"
success "Or from anywhere: source \$(zenv activate @@ENV_NAME@@)"
